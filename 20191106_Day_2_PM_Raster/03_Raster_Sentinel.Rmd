---
title: "Raster Exercise 03 - Sentinel-2 Satellite Imagery"
author: "Alexandre Bevington"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE

---
<!--

  Copyright 2019 Province of British Columbia

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and limitations under the License.

-->


```{r set-up , echo = TRUE, message= FALSE, results = "hide"}

library(tidyverse)

library(raster)
library(RStoolbox)
library(rasterVis)
library(rgdal)

library(mapview)
library(mapedit)

library(purrr)
library(geosphere)

library(RColorBrewer)

library(smoothr)
library(sf)
library(measurements)
library(ggspatial)
```

## Import a Sentinel-2 satellite image 

We start by reading a multispectral Sentinel-2 satellite image usting `raster::stack`. Sentinel-2 acquires imagery using 13 bands, or wavelength groups, resulting in 13 distinct images. Some of these images are 10, 20 and 60 m resolution. Because the `raster::stack` function requires images to have the same spatial resolution, I resampled the red, green, blue and nir bands from 10 to 20 m. We will not use the 60 m bands.  


```{r import, echo = TRUE, message= FALSE}

# Get data
  unzip("../data/20191106_Day_2_PM_Raster/raster_sentinel.zip", exdir = "../data/20191106_Day_2_PM_Raster")

# Make a list of the "TIF" files in a directory of interest (only one in this case)
  files <- list.files(path = "../data/20191106_Day_2_PM_Raster/raster_sentinel", pattern = ".tif$", full.names = T)

# Import stack 
  img <- stack(files)

# Plot 
  plot(img, maxpixels = 1e5)

```

## Change Band Names

```{r band names, echo = TRUE, message = FALSE}

# What are the band names of the stack?
  print(names(img))

# The correct names, in order, are: 
  band_names <- c("blue","green","red","nir","rededge1","rededge2","rededge3","swir1","swir2","vre")

# Assign new names
  names(img) <- band_names

# The new names: 
  names(img)

```

## Plot multiband raster

```{r plot, echo = TRUE, message= FALSE, results = "hide"}

# raster::plot
  plotRGB(x = img, r = "red", g = "green", b = "blue", maxpixels = 1e+05, stretch = "lin")

# mapview::viewRGB
  viewRGB(x = img, r = "nir", g = "red", b = "green", maxpixels = 1e+05)

# RStoolbox::ggRGB
  ggRGB(img = img, r = "swir1", g = "nir", b = "red", maxpixels = 1e+05, stretch = "lin") 
  

```

## Calculat NDVI 

```{r NDVI, echo = TRUE, message= FALSE, results = "hide"}

## Calculate NDVI using custom function

  normalized_difference <- function(img, b1, b2){
      out <- (img[[b1]]-img[[b2]])/(img[[b1]]+img[[b2]])
      return(out)}
  ndvi <- normalized_difference(img, "nir", "red")
  plot(ndvi)
  
# Calculate NDVI using built in RStoolbox function

  ndvi <- spectralIndices(img, red = "red", nir = "nir", indices = "NDVI")
  ggR(ndvi)

```

## Custom palettes

```{r palette, echo = TRUE, message= FALSE, results = "hide"}

display.brewer.all()
display.brewer.pal(n = 10, name = "RdYlGn")
mypal <- brewer.pal(n = 10, name = "RdYlGn")
plot(ndvi, col = mypal)

```

## Reclassify NDVI

```{r reclassify, echo = TRUE, message= FALSE, results = "hide"}

# If between -Ing and 0.4, then reclassify to NA. 
  veg <- reclassify(ndvi, cbind(-Inf, 0.4, NA))
  plot(veg, col = brewer.pal(4, "Greens"))

```
## Plot NDVI and NDVI overlay

```{r rgb, echo = TRUE, message= FALSE, results = "hide"}

plotRGB(img, r="nir", g="red", b="green", axes=TRUE, stretch="lin", main="Landsat False Color Composite with NDVI Overlay",)
plot(veg, col = brewer.pal(9, "Greens"), add=TRUE, legend=FALSE)

```

## KMeans Classification 

```{r kmeans, echo = TRUE, message= FALSE, results = "hide", warning=F}

# Convert raster to numeric
  nr <- getValues(ndvi)

# Set random number generator seed
  set.seed(23)

# Run cluster analysis for 10 groups
  kmncluster <- kmeans(x = na.omit(nr), centers = 10)

# Insert cluster values into the raster structure
  knr <- setValues(ndvi, kmncluster$cluster)

# Plot
  mapview(knr)

```

## Zonal Analysis 

```{r zones, echo = TRUE, message= FALSE, results = "hide"}

# Get mean band values of each zone
  zonal_means <- zonal(x = img, 
                       z = knr, 
                       fun = mean, 
                       na.rm = T)

# Plot the zonal means
  zonal_means %>% 
    as_tibble() %>% 
    gather("band","mean", -zone) %>% 
    mutate(band = factor(band, levels = band_names <- c("blue","green","red","nir","vre","rededge1","rededge2","rededge3","swir1","swir2"))) %>% # Reorder band names
    ggplot(aes(x = band, y = mean, group = zone)) +
      geom_line(aes(color = as.factor(zone))) +
      geom_point(aes(fill = as.factor(zone)), shape = 21, size = 3) + 
      theme_bw() +
      labs(x = "Band Name", 
           y = "Mean Spectral Value", 
           fill = "Zone", 
           color = "Zone", 
           title = "Mean spectral values by kmeans zone")

```

# Extract water class as polygons

```{r water, echo = TRUE, message= FALSE, results = "hide"}

# Make a copy of the classified raster 
  temp <- knr


water_class <- as_tibble(zonal_means) %>% 
  dplyr::filter(nir == min(nir)) %>% 
  dplyr::select(zone) %>% as.numeric()

# Set classes that are not water to NA
  temp[temp != water_class] <- NA 

# Mask the classified raster
  mr <- mask(knr, temp)
  plot(mr)
  
# Set classes that are not water to NA
  mr[mr > 0] <- 1

# Plot
  plot(mr)
```

```{r water-poly, echo = TRUE, message= FALSE, results = "hide"}

# Convert water class to polygons
  mypoly <- rasterToPolygons(x = mr, dissolve = T)

# Remove small chunks and fill holes
  mypoly_filter <- mypoly %>% 
    st_as_sf() %>% 
    st_cast("POLYGON") %>% 
    st_transform(3005) %>% 
    fill_holes(threshold = conv_unit(x = 0.1, from = "km2", to = "m2")) %>%
    mutate(area_m2 = as.numeric(st_area(.))) %>%
    filter(area_m2 >= conv_unit(x = 0.1, from = "km2", to = "m2")) 
  
# Plot water polygons over image
  ggRGB(img = img, r = "red", g = "green", b = "blue", maxpixels = 1e+06, stretch = "lin", alpha = 0.4) +
    geom_sf(data = st_transform(mypoly_filter, crs(img)), color = "darkblue", fill = "blue") +
    theme_classic() +
    scale_x_continuous(expand = c(0,0)) +
    scale_y_continuous(expand = c(0,0)) + 
    labs(x = "", y = "", title = "Water Mask")

``` 
  
```{r export, eval = FALSE}
  ggsave("WaterMask.pdf")
```

## Plot NDVI along a transect

```{r profile-setup, echo = TRUE, message= FALSE, results = "hide"}

# Define line
  line <- cbind(c(-122.67618, -122.81251), c(53.88945, 53.88288)) %>%
    st_linestring() %>% 
    st_sfc(crs = 4326) %>% 
    st_sf()

# Project the raster to the same crs as the line
  ndvi_t <- projectRaster(ndvi, crs = crs(line))

# Plot
  ggR(ndvi_t) + 
    geom_sf(data = line, size = 2, color = "red")

```

```{r profile-extract, echo = TRUE, message= FALSE, results = "hide"}

# Extract values along the lines
  transect <- raster::extract(ndvi_t, line, along = T, cellnumbers=T)

# Clean
  transect_df <- as_tibble(transect[[1]])
  
# Calculate the Cell centroids
  transect_coords = xyFromCell(ndvi_t, transect_df$cell)

# Calculate the distance between cell coordinates
  pair_dist = geosphere::distGeo(transect_coords)[-nrow(transect_coords)]
  
# Calculate the cummulative distance
  transect_df$dist = c(0, cumsum(pair_dist))

# Plot the NDVI transect
  ggplot(transect_df, aes(dist, NDVI)) +
    geom_line() +
    geom_smooth(method = "loess", span = 0.05)

# Plot with OpenStreetMap (Slow first time)  
  # ggR(ndvi_t) + 
  #   annotation_map_tile(zoom = 10, cachedir = system.file("rosm.cache", package = "ggspatial")) +
  #   geom_sf(data = line)
  
````
